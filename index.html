<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="./styles.css" />
    <title>React Hooks Tutorial</title>
  </head>
  <body>
    <div id="content">
      <nav id="navbar">
        <header>React Hooks Tutorial</header>
        <ul>
          <li><a href="#Important_Rules" class="nav-link" rel="internal">Important Rules</a></li>
          <li><a href="#useState" class="nav-link" rel="internal">useState</a></li>
          <li><a href="#useRef" class="nav-link" rel="internal">useRef</a></li>
          <li><a href="#useEffect" class="nav-link" rel="internal">useEffect</a></li>
          <li><a href="#useContext" class="nav-link" rel="internal">useContext</a></li>
          <li><a href="#useReducer" class="nav-link" rel="internal">useReducer</a></li>
          <li><a href="#useCallback" class="nav-link" rel="internal">useCallback</a></li>
          <li><a href="#useMemo" class="nav-link" rel="internal">useMemo</a></li>
          <li><a href="#useImperativeHandle" class="nav-link" rel="internal">useImperativeHandle</a></li>
          <li><a href="#useLayoutEffect" class="nav-link" rel="internal">useLayoutEffect</a></li>
          <li><a href="#useDebugValue" class="nav-link" rel="internal">useDebugValue</a></li>
        </ul>
      </nav>
      <main id="main-doc">
          <section class="main-section" id="Important_Rules">
            <header>Important Rules</header>
            <ul>
              <li>Hooks should never be called from loops, conditionals, or nested functions.</li>
              <li>Hooks should only be at the top level of your component.</li>
              <li>Hooks can only be called in React functional components (not classes).</li>
              <li>Hooks should never be called in regular functions (as opposed to React functional components).</li>
              <li>Hooks can be called from other hooks.</li>
              <li>You can enforce these rules with <a href="https://reactjs.org/docs/hooks-rules.html#eslint-plugin" target="_blank">
                ES Lint</a>.</li>
            </ul>
          </section>
        <section class="main-section" id="useState">
          <header>useState</header>
          <p>React functional components use the <strong>useState</strong> React hook to keep track of "stateful" values, or 
          variable value changes that we need to keep track of in our application.</p>
          <p>In the code below, you can see a typical example of a useState hook.</p>
          <div class="codecontainer">
            <code>
              let initialState = 0;<br />
              const [count, setCount] = useState(initialState);
            </code>
          </div>
          <p>The useState hook is passed an optional initialState parameter, and is assigned to a destructured array that
          tells us the stateful variable's name our program can use, along with a "set" function that our program can use to
          update that variable's value.</p>
          <ul>
            <li><strong>let initialState = 0</strong> is the optional starting value of the count variable.</li>
            <li><strong>count</strong> is the name of the stateful value our program needs to read and update.</li>
            <li><strong>setCount</strong> is the name of the declarative function we will call that will automatically
               update the value of count for us to whatever we tell it to.</li>
          </ul>
          <p>So, in our program, if want to increment count whenever we click a button, the onClick function would
            call <strong>setCount(newCount)</strong> where newCount = ++count;</p>
          </p>
          <p>Example of a functional component using useState to keep track of a counter:</p>
          <div class="codecontainer">
            <xmp>
/* When the "Click Me" button is clicked, the onClick event fires
 * and the incrementCount function is called that uses setCount to 
 * increment the count variable. */

import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);
  const incrementCount = () => setCount(count + 1);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={incrementCount}>Click Me</button>
    </div>
  )
}

export default Counter;
          </xmp>
        </div>
        </p>So for each stateful variable your program needs, the <strong>generalized</strong> 
        format to set up the useState hook is:</p>
        <div class="codecontainer">
            <code>
              const [state, setState] = useState(initialState);
            </code>
         </div>
        </section>
        <section class="main-section" id="useRef">
          <header>useRef</header>
          <p>useRef is a hook that mutates the current value of a variable that we initialize with an initial value.
          Its major difference to the useState hook is that it only updates the value of the variable, but does <strong>not</strong>
          update state. Consequently, useRef does <strong>not</strong> cause a re-render like useState does.</p>
          <p>We create a <strong>ref</strong> for a React functional component like this:</p>
          <div class="codecontainer">
            <code>
              const wasClicked = useRef(false);
            </code>
          </div>
          <p>And we mutate its value using its <strong>current</strong> property:</p>
          <div class="codecontainer">
            <code>
              wasClicked.current = true;
            </code>
          </div>
          <p>If you noticed that wasClicked is a constant, yet we are mutating a value, it is because
          we are updating the property called "current", not mutating the wasClicked object reference itself.</p>
          <p>The functional component below uses a useRef hook. What will be logged to the console? What will appear in the webpage itself (DOM)?</p>
          <div class="codecontainer">
            <xmp>
  import React, { useRef } from "react";

  const clickButton = () => {
    const wasClicked = useRef("Not Clicked Yet");
    const onClick = () => {
      wasClicked.current = "Clicked";
      console.log("Has clicked button? " + wasClicked.current);
    };
  
    return (
      <div>
        <p>The value of wasClicked is: {wasClicked.current}</p>
        <button onClick={onClick}>Click Me</button>
      </div>
    );
  };
  
  export default clickButton;
            </xmp>
          </div>
          <p>The code above will update the value of wasClicked and log it to the console, 
            however it will not cause the page to re-render, so the text in the DOM stays the <strong>same</strong>.</p>
          <ul>
            <li>Console when the component mounts for the first time: nothing in the console</li>
            <li>DOM when the component mounts for the first time: "The value of wasClicked is: Not Clicked Yet"</li>
            <li>Console when the button is clicked: "Has clicked button? Clicked"</li>
            <li>DOM when the button is clicked: "The value of wasClicked is: <strong>Not Clicked Yet</strong>".</li>
          </ul>
          <p>The ref is mutated when the button is clicked, but it does not trigger the DOM to be re-rendered, unlike when we use useState.</p>
          <p>So what would useRef be good for?</p>
          <p>Well, if we wanted to track a state value that changes but shouldn't cause a re-render, we can create a useRef hook to use it as an <strong>instance variable</strong>.</p>
          </p>A good use of this, for example, would be a situation where we want to run certain code whenever a component updates, but <strong>not</strong> when the component is first rendered.</p>
          <p>For most situations, we would use the <a href="#useEffect">useEffect</a> hook to automatically execute the code when the component updates.</p>
          <p>On the other hand, however, the <a href="#useEffect">useEffect</a> hook is also triggered when a component is <strong>first mounted</strong>, which therefore doesn't meet our requirement above.</p>
          <p>In the below code, you can see how we create a variable, using the useRef hook, called firstRender, whose value defaults to true, but is changed to false when the component re-renders. The useEffect hook runs every time a component is rendered or re-rendered, so if we don't want it to run that first time when the component is rendered for the first time, we can check the ref variable firstRender to make sure its value is false before running the code.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useRef, useEffect } from 'react';
export default function ComponentWithRefInstanceVariable() {
  const [count, setCount] = useState(0);
 
  function onClick() {
    setCount(count + 1);
  }
 
  const isFirstRender = .useRef(true);
 
  useEffect(() => {
    if (isFirstRender.current) {

      /* 
      * This is the first time the component is mounted, so DO NOT run the
      * code (in the else statement). Set isFirstRender to false though
      * for when the component loads again.
      */

      isFirstRender.current = false;

    } else {
      // this won't run if isFirstRender.current = true, which is only
      // when the component is FIRST rendered. 
      console.log(
        `
          I am a useEffect hook's logic
          which runs for a component's
          re-render.
        `
      );
    }
  });
 
  return (
    <div>
      <p>{count}</p>
 
      <button type="button" onClick={onClick}>
        Increase
      </button>
    </div>
  );
}
// Code example (Wieruch, 2020). 
            </xmp>
          </div>
        </section>
        <section class="main-section" id="useEffect">
          <header>useEffect</header>
          <p>When we update state, many apps also need to execute side-effects, such as making API calls, communicating with a database, or updating local storage. Since state causes re-renders, we can use the useEffect hook to run our side-effect every time I render or re-render occurs, or just when a certain state value is updated.</p>
          <p>useEffect has a second argument, which when left out, defaults to mean that the side-effect code should execute every time any state value is changed. When this parameter is provided to useEffect, though, we can change when it runs.</p>
          <ol>
            <li>
              <p>Leave out the second argument so code in useEffect runs on mount and re-render of the component:</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  });
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an empty array, which means the useEffect code runs <strong>only</strong> when the component is first mounted, but not when state is updated.</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, []);
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an array containing a list of one or more state variables. When any of these is mutated, execute the useEffect code. Other state variables do not cause the useEffect code to be invoked.</p>
            </li>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, [count, color, loggedIn]);
                </code>
              </div>
          </ol>
          <p>In a component, we can use useEffect as many times as we need! Our code ends up clean and readable, replacing the two lifecycle methods that are required by class components to accomplish the same things (componentDidMount and componentDidUpdate).</p>
          <p>Below, the code contained within the useEffect block executes every time the component is rendered. That is, when it first mounts along with every state update that causes a re-render.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useEffect } from 'react';
export default function useEffectExample() {
  const [count, setCount] = useState(0);
  const [color, setColor] = useState('pink');
 
  function onCountClick() {
    setCount(count + 1);
  }

  function onColorClick() {
    setColor('blue');
  }
 
  useEffect(() => {
    // Executes every time state is changed. 
    // Any state value.
    // i.e. a fetch or axios request.
  });
 
   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the color state changes.
    // i.e. some other side-effect.
  }, [color]);

   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the component mounts for the first time.
    // i.e. some other side-effect.
  }, []);

  return (
    <div>
      <p>{count}</p>
      <button type="button" onClick={onCountClick}>
        Increment Counter
      </button>
      <p>{color}</p>
      <button type="button" onClick={onColorClick}>
        Change Color
      </button>
    </div>
  );
}
            </xmp>
          </div>
          <p>Before another effect runs after a re-render, React will clean up the previous render's effects. Some subscriptions, however, may need useEffect to return a cleanup function (anonymous or named is fine) that automatically executes and unsubscribes.</p>
          <p>The useEffect hook is also wonderful because it does not block the browser when its side-effects are being run, which makes the app feel fast and responsive!</p>
        </section>
        <section class="main-section" id="useContext">
          <header>useContext</header>
          <p>The React useContext hook is used in combination with the React Context API.</p>
          <p>Without using Context in React, props that need to be shared between components are passed as attributes from parent to child to child's child, etc. In addition, functions that mutate the same values are also passed to child components by the parent as attributes that the child component can use to pass mutated props back to the parent.</p>
          <p>As you might guess, if the React tree has many levels of parent and child components, this process could become more error prone and unwieldy. It can be hard to keep track of which props are available to a given component, for instance, and code repetition, such as of attributes and functions that pass to the next parent up the tree, makes code less readable. Moreover, some of the components in the process might not even need access to the prop but have to handle it anyway.</p>
          <p>So, instead of "prop drilling" through multiple levels in a React component tree, we can use the <strong>Context API</strong> and the <strong>useContext</strong> hook to allow prop values to be shared easily between components, without having to explicitly pass them as variables through every level. The steps are actually quite straightforward!</p>
          <ol>
            <li><p>Create a React Context in the highest level of the app that needs access to the values:</p>
              <div class="codecontainer">
                <code>
                  const myContext = React.createContext();
                </code>
              </div>
            </li>
            <li><p>The Context we created is an object that contains two values: { Provider, Consumer }.</p></li>
            <li><p>In the render section, enclose the app's children with myContext.Provider, and add a <strong>value</strong> attribute where we pass our state variables as an object:</p>
                <div class="codecontainer">
                  <xmp>
export default function myApp() {
  const [count, setCount] = useState(1);
  const [greeting, setGreeting] = useState('Hai thar!');

  return (
    <myContext.Provider value={{
      count,
      greeting,
      setCount,
      setGreeting
    }}>
      <div>
        <ChildComponent />
      </div>
    </myContext.Provider>
  );
}
                </xmp>
              </div>
            </li>
            <li><p>To access the state in the myContext.Provider value from any child component that needs it, import React's useContext hook and pass the Context, myContext as a parameter.</p>
              <div class="codecontainer">
                <xmp>
import React, { useContext } from 'react';

export default function ChildComponent() {
  const value = useContext(myContext);
  return <div>The value of the greeting state variable: {value.greeting}</div>;
}
              </xmp>
              </div>      
            </li>
            <li><p>If we want to update state from the ChildComponent, the setGreeting and setCount methods are also available in the Context. Cool!</p>
              <div class="codecontainer">
                  <xmp>
  import React, { useContext } from 'react';
  
  export default function ChildComponent() {
    const value = useContext(myContext);
    return <div>
        <div>The value of the greeting state variable: {value.greeting}</div>
        <label>Update Greeting: </label>
        <input type="text" name="greeting" onChange={e => value.setGreeting(e.target.value)} value={greeting} />
    </div>;
  }
                </xmp>
              </div>  
            </li>
          </ol>
          <p>Importantly, when the values provided by myContext.Provider change, the value will also be updated in all child components that use those values, triggering them to re-render, and the re-renders are <strong>recursive</strong>. That is, if a child component that uses useContext re-renders, all its children <strong>that use the useContext</strong> (but not the children that don't) will also re-render! Hence, the app could take a performance hit. To remedy this, we can use React memo or PureComponent on the children so they don't re-render if they do not need to.</p>
          <p>The React useContext hook also allows us to create multiple Contexts, and we can then nest child components in the ones they need access to.</p>
        </section>
        <section class="main-section" id="useReducer">
          <header>useReducer</header>
          <p>A Reducer is a function that executes code to update global state values depending on an action that is sent (dispatched) to it as a parameter. The name "Reducer" comes from the fact that the reducer function receives two values, an action and the current state object, and reduces it to one that it returns as the new state. Think of the JavaScript array's reduce function that accepts an accumulator and an item to reduce an array to one valus to help remember the concept of a reducer. This pattern is what Redux uses to provide access to state variables from React components.</p>
          <p>Using the <strong>useReducer</strong> hook, our React functional components can also dispatch actions to reducer functions that will run code and mutate state based on the value of the action. An action is essentially just an object with a constant property, "type", that acts as the command sent to the reducer function optionally accompanied by an optional data payload.</p>
          <p>For example, the below code demonstrates, again, the quintessential counter function. This time, however, it uses a reducer function to update the value of the count state variable depending on whether the use dispatches, by choosing a button to click, an "increment", "decrement", or "reset" function.</p>
          <div class="codecontainer">
            <xmp>
import React, { useReducer } from 'react';

const INCREMENT = "increment";
const DECREMENT = "decrement";
const RESET = "reset";
const initialState = 0;

const reducer = (state = initialState, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    case RESET:
      return 0;
    default:
      throw new Error();
  }
}

export default function Counter() {

  const [count, dispatch] = useReducer(reducer, initialState)

  return (<>
    <div>Counter: {count}</div>
    <button onClick={increment=> dispatch({ type: INCREMENT })}>INCREMENT</button>
    <button onClick={decrement=> dispatch({ type: DECREMENT })}>DECREMENT</button>
    <button onClick={reset=> dispatch({ type: RESET })}>RESET</button>
  </>);
}
          </xmp>
        </div>
        <p>useReducer can replace useState, so is often used to manage state that is more complex and needs to be accessed by a tree of components.</p>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useCallback">
          <header>useCallback</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useMemo">
          <header>useMemo</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useImperativeHandle">
          <header>useImperativeHandle</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useLayoutEffect">
          <header>useLayoutEffect</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useDebugValue">
          <header>useDebugValue</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
      </main>
    </div>
    <footer>
        <header>References:</header>
        <p class="reference">Bishard, E. (n.d.). The Guide to Learning React Hooks. Retrieved from 
          <a href="https://www.telerik.com/kendo-react-ui/react-hooks-guide" target="_blank">
            https://www.telerik.com/kendo-react-ui/react-hooks-guide</a>
        </p>
        <p class="reference">ReactJS.org (n.d.). Hooks API Reference. Retrieved from
          <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank">
            https://reactjs.org/docs/hooks-reference.html</a>
        </p>
        <p class="reference">Wieruch, R. (2020, April 25). How to use React Ref. Retrieved from
          <a href="https://www.robinwieruch.de/react-ref" target="_blank">
            https://www.robinwieruch.de/react-ref</a>
        </p> 
    </footer>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="./styles.css" />
    <title>React Hooks Notes</title>
  </head>
  <body>
    <div id="content">
      <nav id="navbar">
        <header>React Hooks Notes</header>
        <ul>
          <li><a href="#Important_Rules" class="nav-link" rel="internal">Important Rules</a></li>
          <li><a href="#useState" class="nav-link" rel="internal">useState</a></li>
          <li><a href="#useRef" class="nav-link" rel="internal">useRef</a></li>
          <li><a href="#useEffect" class="nav-link" rel="internal">useEffect</a></li>
          <li><a href="#useContext" class="nav-link" rel="internal">useContext</a></li>
          <li><a href="#useReducer" class="nav-link" rel="internal">useReducer</a></li>
          <li><a href="#useCallback" class="nav-link" rel="internal">useCallback</a></li>
          <li><a href="#useMemo" class="nav-link" rel="internal">useMemo</a></li>
          <li><a href="#useImperativeHandle" class="nav-link" rel="internal">useImperativeHandle</a></li>
          <li><a href="#useLayoutEffect" class="nav-link" rel="internal">useLayoutEffect</a></li>
          <li><a href="#useDebugValue" class="nav-link" rel="internal">useDebugValue</a></li>
        </ul>
      </nav>
      <main id="main-doc">
          <section class="main-section" id="Important_Rules">
            <header>Important Rules</header>
            <ul>
              <li>Hooks should never be called from loops, conditionals, or nested functions.</li>
              <li>Hooks should only be at the top level of your component.</li>
              <li>Hooks can only be called in React functional components (not classes).</li>
              <li>Hooks should never be called in regular functions (as opposed to React functional components).</li>
              <li>Hooks can be called from other hooks.</li>
              <li>You can enforce these rules with <a href="https://reactjs.org/docs/hooks-rules.html#eslint-plugin" target="_blank">
                ES Lint</a>.</li>
            </ul>
          </section>
        <section class="main-section" id="useState">
          <header>useState</header>
          <p>React functional components use the <strong>useState</strong> React hook to keep track of "stateful" values, or 
          variable value changes that we need to keep track of in our application.</p>
          <p>In the code below, you can see a typical example of a useState hook.</p>
          <div class="codecontainer">
            <code>
              let initialState = 0;<br />
              const [count, setCount] = useState(initialState);
            </code>
          </div>
          <p>The useState hook is passed an optional initialState parameter, and is assigned to a destructured array that
          tells us the stateful variable's name our program can use, along with a "set" function that our program can use to
          update that variable's value.</p>
          <ul>
            <li><strong>let initialState = 0</strong> is the optional starting value of the count variable.</li>
            <li><strong>count</strong> is the name of the stateful value our program needs to read and update.</li>
            <li><strong>setCount</strong> is the name of the declarative function we will call that will automatically
               update the value of count for us to whatever we tell it to.</li>
          </ul>
          <p>So, in our program, if want to increment count whenever we click a button, the onClick function would
            call <strong>setCount(newCount)</strong> where newCount = ++count;</p>
          </p>
          <p>Example of a functional component using useState to keep track of a counter:</p>
          <div class="codecontainer">
            <xmp>
/* When the "Click Me" button is clicked, the onClick event fires
 * and the incrementCount function is called that uses setCount to 
 * increment the count variable. */

import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);
  const incrementCount = () => setCount(count + 1);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={incrementCount}>Click Me</button>
    </div>
  )
}

export default Counter;
          </xmp>
        </div>
        </p>So for each stateful variable your program needs, the <strong>generalized</strong> 
        format to set up the useState hook is:</p>
        <div class="codecontainer">
            <code>
              const [state, setState] = useState(initialState);
            </code>
         </div>
        </section>
        <section class="main-section" id="useRef">
          <header>useRef</header>
          <p>useRef is a hook that mutates the current value of a variable that we can optionally initialize with an initial value, or leave undefined.
          Its major difference to the useState hook is that it only updates the value of the variable, but does <strong>not</strong>
          update state. Consequently, useRef does <strong>not</strong> cause a re-render like useState does, and we can use it when storing a value in state is not wanted or necessary.</p>
          <p>We create a <strong>ref</strong> for a React functional component like this:</p>
          <div class="codecontainer">
            <code>
              const wasClicked = useRef(false);
            </code>
          </div>
          <p>And we mutate its value using its <strong>current</strong> property:</p>
          <div class="codecontainer">
            <code>
              wasClicked.current = true;
            </code>
          </div>
          <p>If you noticed that wasClicked is a constant, yet we are mutating a value, it is because
          we are updating the property called "current", not mutating the wasClicked object reference itself.</p>
          <p>The functional component below uses a useRef hook. What will be logged to the console? What will appear in the webpage itself (DOM)?</p>
          <div class="codecontainer">
            <xmp>
  import React, { useRef } from "react";

  const clickButton = () => {
    const wasClicked = useRef("Not Clicked Yet");
    const onClick = () => {
      wasClicked.current = "Clicked";
      console.log("Has clicked button? " + wasClicked.current);
    };
  
    return (
      <div>
        <p>The value of wasClicked is: {wasClicked.current}</p>
        <button onClick={onClick}>Click Me</button>
      </div>
    );
  };
  
  export default clickButton;
            </xmp>
          </div>
          <p>The code above will update the value of wasClicked and log it to the console, 
            however it will not cause the page to re-render, so the text in the DOM stays the <strong>same</strong>.</p>
          <ul>
            <li>Console when the component mounts for the first time: nothing in the console</li>
            <li>DOM when the component mounts for the first time: "The value of wasClicked is: Not Clicked Yet"</li>
            <li>Console when the button is clicked: "Has clicked button? Clicked"</li>
            <li>DOM when the button is clicked: "The value of wasClicked is: <strong>Not Clicked Yet</strong>".</li>
          </ul>
          <p>The ref is mutated when the button is clicked, but it does not trigger the DOM to be re-rendered, unlike when we use useState.</p>
          <p>So what would useRef be good for?</p>
          <p>Well, if we wanted to track a state value that changes but shouldn't cause a re-render, we can create a useRef hook to use it as an <strong>instance variable</strong>.</p>
          </p>A good use of this, for example, would be a situation where we want to run certain code whenever a component updates, but <strong>not</strong> when the component is first rendered.</p>
          <p>For most situations, we would use the <a href="#useEffect">useEffect</a> hook to automatically execute the code when the component updates.</p>
          <p>On the other hand, however, the <a href="#useEffect">useEffect</a> hook is also triggered when a component is <strong>first mounted</strong>, which therefore doesn't meet our requirement above.</p>
          <p>In the below code, you can see how we create a variable, using the useRef hook, called firstRender, whose value defaults to true, but is changed to false when the component re-renders. The useEffect hook runs every time a component is rendered or re-rendered, so if we don't want it to run that first time when the component is rendered for the first time, we can check the ref variable firstRender to make sure its value is false before running the code.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useRef, useEffect } from 'react';
export default function ComponentWithRefInstanceVariable() {
  const [count, setCount] = useState(0);
 
  function onClick() {
    setCount(count + 1);
  }
 
  const isFirstRender = .useRef(true);
 
  useEffect(() => {
    if (isFirstRender.current) {

      /* 
      * This is the first time the component is mounted, so DO NOT run the
      * code (in the else statement). Set isFirstRender to false though
      * for when the component loads again.
      */

      isFirstRender.current = false;

    } else {
      // this won't run if isFirstRender.current = true, which is only
      // when the component is FIRST rendered. 
      console.log(
        `
          I am a useEffect hook's logic
          which runs for a component's
          re-render.
        `
      );
    }
  });
 
  return (
    <div>
      <p>{count}</p>
 
      <button type="button" onClick={onClick}>
        Increase
      </button>
    </div>
  );
}
// Code example (Wieruch, 2020). 
            </xmp>
          </div>
          <p>The useRef hook is frequently used with DOM elements in order to get their values out without having to store them in state. The useRef hook contains a reference to a DOM node which we can then access directly.</p>
          <p>In the below code example, you can see how we can make a useRef object we name inputRef, and pass inputRef to the ref attribute of a text input field. Now, we can access the value of the text field with the inputRef object's <strong>current</strong> property, <strong>inputRef.current</strong>.</p>
          <div class="codecontainer">
            <xmp>
  import React, { useRef } from 'react';
  export default function ComponentWithRefForDOMElement() {

    const inputRef = useRef();
   
    function onSubmit(event) {
      event.preventDefault();

      // Will log the current value of the text field to the console.
      console.log(inputRef.current.value); // whatever you've typed in the field.

      // Will log which DOM node inputRef refers to, along with its attributes, 
      // including name, id, style, etc. if present.
      console.log(inputRef.current); // <input name="wow" id="lol" style="color: red;">

      // Changes the style of the inputRef's text to blue!
      inputRef.current.style = "color: blue";
    }
    
    return (
      <>
        {/* <p>{inputRef.current.value}</p> */}
        <form onSubmit={onSubmit}>
          <input id="hi" name="ho" style={{ color: "red" }} ref={inputRef} />
        </form>
      </>
    );
  } 
            </xmp>
          </div>
          <p>Observe that while we can log the inputRef to the console or change styles, a change in value that we type is <strong>not</strong> updated in the DOM (where we have &lt;p&gt;{inputRef.current.value}&lt;/p&gt;).</p>
          <p> That is, we cannot see the changes to value in the DOM, and get an error when the component loads if we try to access it, if the initial value is undefined. If the initial state is <strong>not</strong> undefined, we still see nothing in the DOM.</p>
        </section>
        <section class="main-section" id="useEffect">
          <header>useEffect</header>
          <p>When we update state, many apps also need to execute side-effects, such as making API calls, communicating with a database, or updating local storage. Since state causes re-renders, we can use the useEffect hook to run our side-effect every time I render or re-render occurs, or just when a certain state value is updated.</p>
          <p>useEffect has a second argument, which when left out, defaults to mean that the side-effect code should execute every time any state value is changed. When this parameter is provided to useEffect, though, we can change when it runs.</p>
          <ol>
            <li>
              <p>Leave out the second argument so code in useEffect runs on mount and re-render of the component:</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  });
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an empty array, which means the useEffect code runs <strong>only</strong> when the component is first mounted, but not when state is updated.</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, []);
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an array containing a list of one or more state variables. When any of these is updated, execute the useEffect code. Other state variables do not cause the useEffect code to be invoked.</p>
            </li>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, [count, color, loggedIn]);
                </code>
              </div>
          </ol>
          <p>In a component, we can use useEffect as many times as we need! Our code ends up clean and readable, replacing the two lifecycle methods that are required by class components to accomplish the same things (componentDidMount and componentDidUpdate).</p>
          <p>Below, the code contained within the useEffect block executes every time the component is rendered. That is, when it first mounts along with every state update that causes a re-render.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useEffect } from 'react';
export default function useEffectExample() {
  const [count, setCount] = useState(0);
  const [color, setColor] = useState('pink');
 
  function onCountClick() {
    setCount(count + 1);
  }

  function onColorClick() {
    setColor('blue');
  }
 
  useEffect(() => {
    // Executes every time state is changed. 
    // Any state value.
    // i.e. a fetch or axios request.
  });
 
   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the color state changes.
    // i.e. some other side-effect.
  }, [color]);

   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the component mounts for the first time.
    // i.e. some other side-effect.
  }, []);

  return (
    <div>
      <p>{count}</p>
      <button type="button" onClick={onCountClick}>
        Increment Counter
      </button>
      <p>{color}</p>
      <button type="button" onClick={onColorClick}>
        Change Color
      </button>
    </div>
  );
}
            </xmp>
          </div>
          <p>Before another effect runs after a re-render, React will clean up the previous render's effects. Some subscriptions, however, may need useEffect to return a cleanup function (anonymous or named is fine) that automatically executes and unsubscribes.</p>
          <p>The useEffect hook is also wonderful because it does not block the browser when its side-effects are being run, which makes the app feel fast and responsive!</p>
        </section>
        <section class="main-section" id="useContext">
          <header>useContext</header>
          <p>The React useContext hook is used in combination with the React Context API.</p>
          <p>Without using Context in React, props that need to be shared between components are passed as attributes from parent to child to child's child, etc. In addition, functions that update the same values are also passed to child components by the parent as attributes that the child component can use to pass updated props back to the parent.</p>
          <p>As you might guess, if the React tree has many levels of parent and child components, this process could become more error prone and unwieldy. It can be hard to keep track of which props are available to a given component, for instance, and code repetition, such as of attributes and functions that pass to the next parent up the tree, makes code less readable. Moreover, some of the components in the process might not even need access to the prop but have to handle it anyway.</p>
          <p>So, instead of "prop drilling" through multiple levels in a React component tree, we can use the <strong>Context API</strong> and the <strong>useContext</strong> hook to allow prop values to be shared easily between components, without having to explicitly pass them as variables through every level. The steps are actually quite straightforward!</p>
          <ol>
            <li><p>Create a React Context in the highest level of the app that needs access to the values:</p>
              <div class="codecontainer">
                <code>
                  const myContext = React.createContext();
                </code>
              </div>
            </li>
            <li><p>The Context we created is an object that contains two values: { Provider, Consumer }.</p></li>
            <li><p>In the render section, enclose the app's children with myContext.Provider, and add a <strong>value</strong> attribute where we pass our state variables as an object:</p>
                <div class="codecontainer">
                  <xmp>
export default function myApp() {
  const [count, setCount] = useState(1);
  const [greeting, setGreeting] = useState('Hai thar!');

  return (
    <myContext.Provider value={{
      count,
      greeting,
      setCount,
      setGreeting
    }}>
      <div>
        <ChildComponent />
      </div>
    </myContext.Provider>
  );
}
                </xmp>
              </div>
            </li>
            <li><p>To access the state in the myContext.Provider value from any child component that needs it, import React's useContext hook and pass the Context, myContext as a parameter.</p>
              <div class="codecontainer">
                <xmp>
import React, { useContext } from 'react';

export default function ChildComponent() {
  const value = useContext(myContext);
  return <div>The value of the greeting state variable: {value.greeting}</div>;
}
              </xmp>
              </div>      
            </li>
            <li><p>If we want to update state from the ChildComponent, the setGreeting and setCount methods are also available in the Context. Cool!</p>
              <div class="codecontainer">
                  <xmp>
  import React, { useContext } from 'react';
  
  export default function ChildComponent() {
    const value = useContext(myContext);
    return <div>
        <div>The value of the greeting state variable: {value.greeting}</div>
        <label>Update Greeting: </label>
        <input type="text" name="greeting" onChange={e => value.setGreeting(e.target.value)} value={greeting} />
    </div>;
  }
                </xmp>
              </div>  
            </li>
          </ol>
          <p>Importantly, when the values provided by myContext.Provider change, the value will also be updated in all child components that use those values, triggering them to re-render, and the re-renders are <strong>recursive</strong>. That is, if a child component that uses useContext re-renders, all its children <strong>that use the useContext</strong> (but not the children that don't) will also re-render! Hence, the app could take a performance hit. To remedy this, we can use React memo or PureComponent on the children so they don't re-render if they do not need to.</p>
          <p>The React useContext hook also allows us to create multiple Contexts, and we can then nest child components in the ones they need access to.</p>
        </section>
        <section class="main-section" id="useReducer">
          <header>useReducer</header>
          <p>A reducer is a function that executes code to update global state values depending on an action that is sent (dispatched) to it as a parameter. The name "reducer" comes from the fact that the reducer function receives two values, an action and the current state object. It then "reduces" these two values into one that it returns as the new state. To help remember the concept of a reducer, think of the Array reduce method that accepts 1) an accumulator and 2) each item of the array, to reduce an array to a single value. This pattern is what Redux uses to provide access to state variables from React components. Ultimately, a reducer takes in an action and a previous state value, and returns a new state.</p>
          <p>There are several important rules for a reducer function to follow:</p>
          <ul>
            <li>The code inside the reducer function should never mutate its arguments, which are the current state and the dispatched action. To return a new state, a copy of the original should be made first.</li>
            <li>The reducer code should not be generating side effects, such as database or API calls. It should be a pure function.</li>
            <li>As well, any functions that the reducer calls within its code should always be pure functions themselves. That is, their output should only depend on their input. For example, Date.now() or Math.random() are <strong>not</strong> pure functions.</li>
          </ul>
          <p>(Copes, 2019)</p>
          <p>Using the <strong>useReducer</strong> hook, our React functional components can also dispatch actions to reducer functions that will run code and update a new copy of state based on the value of the action. An action is essentially just an object with a constant property, "type", that acts as the command sent to the reducer function optionally accompanied by an optional data payload. *By default react will pass the state to the dispatcher. but if you want to pass some data the you can add it in the object and pass that object to dispatch.</p>
          <p>For example, the below code demonstrates, again, a quintessential counter function. This time, however, it uses a reducer function to update the value of the count state depending on whether the user dispatches, by choosing a button to click, an "increment", "decrement", or "reset" action. Notice, as well, that the dispatch function expects its parameter to be an <strong>object</strong> type.</p>
          <div class="codecontainer">
            <xmp>
import React, { useReducer } from 'react';

const INCREMENT = "increment";
const DECREMENT = "decrement";
const RESET = "reset";
const initialArg = 0;

const reducer = (state = initialArg, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    case RESET:
      return 0;
    default:
      <!-- throw new Error(); -->
      return state;
  }
}

export default function Counter() {

  const [count, dispatch] = useReducer(reducer, initialArg)

  return (<>
    <div>Counter: {count}</div>
    <button onClick={increment=> dispatch({ type: INCREMENT })}>INCREMENT</button>
    <button onClick={decrement=> dispatch({ type: DECREMENT })}>DECREMENT</button>
    <button onClick={reset=> dispatch({ type: RESET })}>RESET</button>
  </>);
}
          </xmp>
        </div>
        <p>Sometimes, you will see a useReducer hook with three parameters instead of two. In addition to the reducer and the initialArg parameters is a third <strong>init function</strong>. 
        <div class="codecontainer">
          <code>
            const [state, dispatch] = useReducer(reducer, initialArg, init);
          </code>
        </div>
        <p>We can create an init function and pass it as a parameter to the useReducer hook in order to create the initial state <strong>lazily</strong>, meaning that we can now calculate the initial state outside the reducer or reset it because of a certain action. We don't need to compute the initial state, that is, until it is needed. Notice in the code below how the reducer calls the init function in response to the "reset" action, which is calculated at that time only.</p>
        <div class="codecontainer">
          <xmp>
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}

// Code sample from (Reactjs.org, n.d.)
          </xmp>
        </div>
        <p>useReducer is much like useState, except that it has a reducer function as an intermediary for when we need to change the state (Ceddia, 2018). Thus, instead of setting state directly, we can execute the dispatch function with any action, and the reducer will execute code based on the action it receives. The reducer will ultimately update the state and return it, and the state change will therefore cause a re-render.</p>
        <p>The useReducer hook, then, is often used instead of useState to manage state that is more complex that primitive values, such as nested objects and arrays. It is more suited to code where the state depends on the previous state, since that is received by the reducer function.</p>
        <div class="codecontainer">
          <xmp>
const [state, dispatch] = React.useReducer(
  fetchUsersReducer,
  {
    users: [
      { name: 'John', subscribred: false },
      { name: 'Jane', subscribred: true },
    ],
    loading: false,
    error: false,
  },
);
          </xmp>
        </div>
        <p>The code above shows a state with a complicated shape. If any parameters depend on each other, also, the useReducer hook allows us to encapsulate everything nicely into the single reducer function.</p>
        <p>Finally, since a reducer is a pure function that always returns the same output for the same input parameters with zero side effects, it is suited for testing, since it does not depend on React (Spukas, 2019).</p>

      <!-- USE EXAMPLE FROM youtube tutorial (Dave Ceddia) -->    
      
        </section>
        <section class="main-section" id="useCallback">
          <header>useCallback</header>
          <p>When you have a child component that needs to re-render often, all of its functions must be reinstantiated as well, even those that handle a different state variable than the one that changed. Although this might not be noticeable in a small component, it can cause a performance hit in a component that has multiple state values that are changed independently of others.</p>
          <p>So, if one state value is changed, it should only cause functions that access it to reinstantiate, and leave functions that do not alone.</p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useMemo">
          <header>useMemo</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useImperativeHandle">
          <header>useImperativeHandle</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useLayoutEffect">
          <header>useLayoutEffect</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useDebugValue">
          <header>useDebugValue</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
      </main>
    </div>
    <footer>
        <header>References:</header>
        <p class="reference">Bishard, E. (n.d.). The Guide to Learning React Hooks. Retrieved from 
          <a href="https://www.telerik.com/kendo-react-ui/react-hooks-guide" target="_blank">
            https://www.telerik.com/kendo-react-ui/react-hooks-guide</a>
        </p>
        <p class="reference">Ceddia, D. (2018, October 30). How to Use the useReducer Hook. Retrieved from 
            <a href="https://daveceddia.com/usereducer-hook-examples" target="_blank">
              https://daveceddia.com/usereducer-hook-examples</a>
        </p>
        <p class="reference">Ceddia, D. (2019, January 30). The useReducer Hook. Retrieved from 
          <a href="https://www.youtube.com/watch?time_continue=1&v=sYDFCuZHrqw&feature=emb_logo" target="_blank">
            https://www.youtube.com/watch?time_continue=1&v=sYDFCuZHrqw&feature=emb_logo</a>
        </p>
        <p class="reference">Copes, F. (2019, July 23). How to use the useReducer React hook. Retrieved from 
            <a href="https://flaviocopes.com/react-hook-usereducer" target="_blank">
              https://flaviocopes.com/react-hook-usereducer</a>
        </p>
        <p class="reference">ReactJS.org (n.d.). Hooks API Reference. Retrieved from
          <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank">
            https://reactjs.org/docs/hooks-reference.html</a>
        </p>
        <p class="reference">Spukas, L. (2019, August 18). 3 Reasons to useReducer() over useState(). Retrieved from
          <a href="https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad" target="_blank">
            https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad</a>
        </p>
        <p class="reference">Wieruch, R. (2020, April 25). How to use React Ref. Retrieved from
          <a href="https://www.robinwieruch.de/react-ref" target="_blank">
            https://www.robinwieruch.de/react-ref</a>
        </p> 
    </footer>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="./styles.css" />
    <title>React Hooks Notes</title>
  </head>
  <body>
    <div id="content">
      <nav id="navbar">
        <header>React Hooks Notes</header>
        <ul>
          <li><a href="#Important_Rules" class="nav-link" rel="internal">Important Rules</a></li>
          <li><a href="#useState" class="nav-link" rel="internal">useState</a></li>
          <li><a href="#useRef" class="nav-link" rel="internal">useRef</a></li>
          <li><a href="#useEffect" class="nav-link" rel="internal">useEffect</a></li>
          <li><a href="#useContext" class="nav-link" rel="internal">useContext</a></li>
          <li><a href="#useReducer" class="nav-link" rel="internal">useReducer</a></li>
          <li><a href="#useCallback" class="nav-link" rel="internal">useCallback</a></li>
          <li><a href="#useMemo" class="nav-link" rel="internal">useMemo</a></li>
          <li><a href="#useImperativeHandle" class="nav-link" rel="internal">useImperativeHandle</a></li>
          <li><a href="#useLayoutEffect" class="nav-link" rel="internal">useLayoutEffect</a></li>
          <li><a href="#useDebugValue" class="nav-link" rel="internal">useDebugValue</a></li>
        </ul>
      </nav>
      <main id="main-doc">
          <section class="main-section" id="Important_Rules">
            <header>Important Rules</header>
            <ul>
              <li>Hooks should never be called from loops, conditionals, or nested functions.</li>
              <li>Hooks should only be at the top level of your component.</li>
              <li>Hooks can only be called in React functional components (not classes).</li>
              <li>Hooks should never be called in regular functions (as opposed to React functional components).</li>
              <li>Hooks can be called from other hooks.</li>
              <li>You can enforce these rules with <a href="https://reactjs.org/docs/hooks-rules.html#eslint-plugin" target="_blank">
                ES Lint</a>.</li>
            </ul>
          </section>
        <section class="main-section" id="useState">
          <header>useState</header>
          <p>React functional components use the <strong>useState</strong> React hook to keep track of "stateful" values, or 
          variable value changes that we need to keep track of in our application.</p>
          <p>In the code below, you can see a typical example of a useState hook.</p>
          <div class="codecontainer">
            <code>
              let initialState = 0;<br />
              const [count, setCount] = useState(initialState);
            </code>
          </div>
          <p>The useState hook is passed an optional initialState parameter, and is assigned to a destructured array that
          tells us the stateful variable's name our program can use, along with a "set" function that our program can use to
          update that variable's value.</p>
          <ul>
            <li><strong>let initialState = 0</strong> is the optional starting value of the count variable.</li>
            <li><strong>count</strong> is the name of the stateful value our program needs to read and update.</li>
            <li><strong>setCount</strong> is the name of the declarative function we will call that will automatically
               update the value of count for us to whatever we tell it to.</li>
          </ul>
          <p>So, in our program, if want to increment count whenever we click a button, the onClick function would
            call <strong>setCount(newCount)</strong> where newCount = ++count;</p>
          </p>
          <p>Example of a functional component using useState to keep track of a counter:</p>
          <div class="codecontainer">
            <pre>
/* When the "Click Me" button is clicked, the onClick event fires
 * and the incrementCount function is called that uses setCount to 
 * increment the count variable. */

import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);
  const incrementCount = () => setCount(count + 1);

  return (
    &lt;&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={incrementCount}&gt;Click Me&lt;/button&gt;
    &lt;/&gt;
  );
}

export default Counter;
          </pre>
        </div>
        </p>So for each stateful variable your program needs, the <strong>generalized</strong> 
        format to set up the useState hook is:</p>
        <div class="codecontainer">
            <code>
              const [state, setState] = useState(initialState);
            </code>
         </div>
        </section>
        <section class="main-section" id="useRef">
          <header>useRef</header>
          <p>useRef is a hook that mutates the current value of a variable that we can optionally initialize with an initial value, or leave undefined.
          Its major difference to the useState hook is that it only updates the value of the variable, but does <strong>not</strong>
          update state. Consequently, useRef does <strong>not</strong> cause a re-render like useState does, and we can use it when storing a value in state is not wanted or necessary.</p>
          <p>We create a <strong>ref</strong> for a React functional component like this:</p>
          <div class="codecontainer">
            <code>
              const wasClicked = useRef(false);
            </code>
          </div>
          <p>And we mutate its value using its <strong>current</strong> property:</p>
          <div class="codecontainer">
            <code>
              wasClicked.current = true;
            </code>
          </div>
          <p>If you noticed that wasClicked is a constant, yet we are mutating a value, it is because
          we are updating the property called "current", not mutating the wasClicked object reference itself.</p>
          <p>The functional component below uses a useRef hook. What will be logged to the console? What will appear in the webpage itself (DOM)?</p>
          <div class="codecontainer">
            <pre>
  import React, { useRef } from "react";

  const clickButton = () => {
    const wasClicked = useRef("Not Clicked Yet");
    const onClick = () => {
      wasClicked.current = "Clicked";
      console.log("Has clicked button? " + wasClicked.current);
    };
  
    return (
      &lt;&gt;
        &lt;p&gt;The value of wasClicked is: {wasClicked.current}&lt;/p&gt;
        &lt;button onClick={onClick}&gt;Click Me&lt;/button&gt;
      &lt;/&gt;
    );
  };
  
  export default clickButton;
            </pre>
          </div>
          <p>The code above will update the value of wasClicked and log it to the console, 
            however it will not cause the page to re-render, so the text in the DOM stays the <strong>same</strong>.</p>
          <ul>
            <li>Console when the component mounts for the first time: nothing in the console</li>
            <li>DOM when the component mounts for the first time: "The value of wasClicked is: Not Clicked Yet"</li>
            <li>Console when the button is clicked: "Has clicked button? Clicked"</li>
            <li>DOM when the button is clicked: "The value of wasClicked is: <strong>Not Clicked Yet</strong>".</li>
          </ul>
          <p>The ref is mutated when the button is clicked, but it does not trigger the DOM to be re-rendered, unlike when we use useState.</p>
          <p>So what would useRef be good for?</p>
          <p>Well, if we wanted to track a state value that changes but shouldn't cause a re-render, we can create a useRef hook to use it as an <strong>instance variable</strong>.</p>
          </p>A good use of this, for example, would be a situation where we want to run certain code whenever a component updates, but <strong>not</strong> when the component is first rendered.</p>
          <p>For most situations, we would use the <a href="#useEffect">useEffect</a> hook to automatically execute the code when the component updates.</p>
          <p>On the other hand, however, the <a href="#useEffect">useEffect</a> hook is also triggered when a component is <strong>first mounted</strong>, which therefore doesn't meet our requirement above.</p>
          <p>In the below code, you can see how we create a variable, using the useRef hook, called firstRender, whose value defaults to true, but is changed to false when the component re-renders. The useEffect hook runs every time a component is rendered or re-rendered, so if we don't want it to run that first time when the component is rendered for the first time, we can check the ref variable firstRender to make sure its value is false before running the code.</p>
          <div class="codecontainer">
            <pre>
import React, { useState, useRef, useEffect } from 'react';

export default function ComponentWithRefInstanceVariable() {
  const [count, setCount] = useState(0);
 
  function onClick() {
    setCount(count + 1);
  }
 
  const isFirstRender = useRef(true);
 
  useEffect(() => {
    if (isFirstRender.current) {

      /* 
      * This is the first time the component is mounted, so DO NOT run the
      * code (in the else statement). Set isFirstRender to false though
      * for when the component loads again.
      */

      isFirstRender.current = false;

    } else {
      // this won't run if isFirstRender.current = true, which is only
      // when the component is FIRST rendered. 
      console.log(
        `
          I am a useEffect hook's logic
          which runs for a component's
          re-render.
        `
      );
    }
  });
 
  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
 
      &lt;button type="button" onClick={onClick}&gt;
        Increase
      &lt;/button&gt;
    &lt;/&gt;
  );
}
// Code example (Wieruch, 2020). 
            </pre>
          </div>
          <p>The useRef hook is frequently used with DOM elements in order to get their values out without having to store them in state. The useRef hook contains a reference to a DOM node which we can then access directly. This is the React way of accessing an HTML element instead of using things like getElementById.</p>
          <p>In the below code example, you can see how we can make a useRef object we name inputRef, and pass inputRef to the ref attribute of a text input field. Now, we can access the value of the text field with the inputRef object's <strong>current</strong> property, <strong>inputRef.current</strong>.</p>
          <div class="codecontainer">
            <pre>
  // ComponentWithRefForDOMElement component.
  import React, { useRef } from 'react';

  export default function ComponentWithRefForDOMElement() {

    const inputRef = useRef();
   
    function onSubmit(event) {
      event.preventDefault();

      // Will log the current value of the text field to the console.
      console.log(inputRef.current.value); // whatever you've typed in the field.

      // Will log which DOM node inputRef refers to, along with its attributes, 
      // including name, id, style, etc. if present.
      console.log(inputRef.current); // &lt;input type="text" id="lol" style="color: red;"&gt;

      // Changes the style of the inputRef's text to blue!
      inputRef.current.style = "color: blue";
    }
    
    return (
      &lt;&gt;
        {/* &lt;p&gt;{inputRef.current.value}&lt;/p&gt; */}
        &lt;form onSubmit={onSubmit}&gt;
          &lt;input type="text" id="lol" style={{ color: "red" }} ref={inputRef} /&gt;
        &lt;/form&gt;
      &lt;/&gt;
    );
  } 
            </pre>
          </div>
          <p>Observe that while we can log the inputRef to the console or change styles, a change in value that we type is <strong>not</strong> updated in the DOM (where we have &lt;p&gt;{inputRef.current.value}&lt;/p&gt;).</p>
          <p> That is, we cannot see the changes to value in the DOM, and get an error when the component loads if we try to access it, if the initial value is undefined. If the initial state is <strong>not</strong> undefined, we still see nothing in the DOM.</p>
          <p><strong>forwardRef:</strong></p>
          <p>Above, we only need to include the useRef hook by adding the ref attribute to the input field (the ref={inputRef} part), but what do we do when the DOM nodes we need to access are in a child component instead? That is, how would we access the input field in a case like this, where the input field is actually inside a child component instead of directly in the return statement of the ComponentWithRefForDOMElement component?</p>
          <div class="codecontainer">
            <pre>
  // ComponentWithRefForDOMElement component.
  import React, { useRef } from 'react';

  import ChildComponentWithTheInputField from './ChildComponentWithTheInputField';

  export default function ComponentWithRefForDOMElement() {

    const inputRef = useRef();
   
    function onSubmit(event) {
      event.preventDefault();

      // Will log the current value of the text field to the console.
      console.log(inputRef.current.value); // whatever you've typed in the field.

      // Will log which DOM node inputRef refers to, along with its attributes, 
      // including name, id, style, etc. if present.
      console.log(inputRef.current); // &lt;input type="text" id="lol" style="color: red;"&gt;

      // Changes the style of the inputRef's text to blue!
      inputRef.current.style = "color: blue";
    }
    
    return (
      &lt;&gt;
        {/* &lt;p&gt;{inputRef.current.value}&lt;/p&gt; */}
        &lt;form onSubmit={onSubmit}&gt;
          &lt;ChildComponentWithTheInputField id="lol" style={{ color: "red" }} ref={inputRef} /&gt;
        &lt;/form&gt;
      &lt;/&gt;
    );
  } 

  ////////////////////////////////////////////////////////////////////

  // ChildComponentWithTheInputField
  import React from 'react';

  const ChildComponentWithTheInputField = () => {
    return (
      &lt;input /&gt;
    );
  }
  
  export default ChildComponentWithTheInputField;

            </pre>
          </div>
          <p>See how we have "ChildComponentWithTheInputField" in the parent component's (ComponentWithRefForDOMElement) return statement instead of &lt;input type="text" id="lol" style={{ color: "red" }} ref={inputRef} /&gt;? How do we use refs in this situation to access the input DOM node? we don't have access to the references directly!</p>
          <p>Well, it turns out that all we have to do is pass the ref as another parameter to the child component after the props (either as ...props or destructured below as {type, id, style}), then we can include the ref in the atttributes of the input field in the child component's (ChildComponentWithTheInputField) return statement.</p>
          <p>Then, we create a constant of the child component that we export as a forwarded ref instead of the child component directly.</p>
          <div class="codecontainer">
              <pre>
    // ChildComponentWithTheInputField
    import React from 'react';
  
    const ChildComponentWithTheInputField = ({type, id, style}, ref) => {
      return (
        &lt;input ref={ref} type={type} id={id} style={style} /&gt;
      );
    }

    const forwardedChildComponentRef = React.forwardRef(ChildComponentWithTheInputField);

    export default forwardedChildComponentRef;
              </pre>
          </div>
          <p>Thus, forwardRef is just when we need to forward a reference into a component. Nothing needs to change in the parent component, and all we need to do in the child is to add a ref parameter and create a forwardRef version of the child component to export for use in other components (such as the parent).</p>
        </section>
        <section class="main-section" id="useEffect">
          <header>useEffect</header>
          <p>When we update state, many apps also need to execute side-effects, such as making API calls, communicating with a database, or updating local storage. Since state causes re-renders, we can use the useEffect hook to run our side-effect every time I render or re-render occurs, or just when a certain state value is updated.</p>
          <p>useEffect has a second argument, which when left out, defaults to mean that the side-effect code should execute every time any state value is changed. When this parameter is provided to useEffect, though, we can change when it runs.</p>
          <ol>
            <li>
              <p>Leave out the second argument so code in useEffect runs on mount and re-render of the component:</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  });
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an empty array, which means the useEffect code runs <strong>only</strong> when the component is first mounted, but not when state is updated.</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, []);
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an array containing a list of one or more state variables. When any of these is updated, execute the useEffect code. Other state variables do not cause the useEffect code to be invoked.</p>
            </li>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, [count, color, loggedIn]);
                </code>
              </div>
          </ol>
          <p>In a component, we can use useEffect as many times as we need! Our code ends up clean and readable, replacing the two lifecycle methods that are required by class components to accomplish the same things (componentDidMount and componentDidUpdate).</p>
          <p>Below, the code contained within the useEffect block executes every time the component is rendered. That is, when it first mounts along with every state update that causes a re-render.</p>
          <div class="codecontainer">
            <pre>
import React, { useState, useEffect } from 'react';
export default function useEffectExample() {
  const [count, setCount] = useState(0);
  const [color, setColor] = useState('pink');
 
  function onCountClick() {
    setCount(count + 1);
  }

  function onColorClick() {
    setColor('blue');
  }
 
  useEffect(() => {
    // Executes every time state is changed. 
    // Any state value.
    // i.e. a fetch or axios request.
  });
 
   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the color state changes.
    // i.e. some other side-effect.
  }, [color]);

   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the component mounts for the first time.
    // i.e. some other side-effect.
  }, []);

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button type="button" onClick={onCountClick}&gt;
        Increment Counter
      &lt;/button&gt;
      &lt;p&gt;{color}&lt;/p&gt;
      &lt;button type="button" onClick={onColorClick}&gt;
        Change Color
      &lt;/button&gt;
    &lt;/&gt;
  );
}
            </pre>
          </div>
          <p>Before another effect runs after a re-render, React will clean up the previous render's effects. Some subscriptions, however, may need useEffect to return a cleanup function (anonymous or named is fine) that automatically executes and unsubscribes.</p>
          <p>The useEffect hook is also wonderful because it does not block the browser when its side-effects are being run, which makes the app feel fast and responsive!</p>
        </section>
        <section class="main-section" id="useContext">
          <header>useContext</header>
          <p>The React useContext hook is used in combination with the React Context API.</p>
          <p>Without using Context in React, props that need to be shared between components are passed as attributes from parent to child to child's child, etc. In addition, functions that update the same values are also passed to child components by the parent as attributes that the child component can use to pass updated props back to the parent.</p>
          <p>As you might guess, if the React tree has many levels of parent and child components, this process could become more error prone and unwieldy. It can be hard to keep track of which props are available to a given component, for instance, and code repetition, such as of attributes and functions that pass to the next parent up the tree, makes code less readable. Moreover, some of the components in the process might not even need access to the prop but have to handle it anyway.</p>
          <p>So, instead of "prop drilling" through multiple levels in a React component tree, we can use the <strong>Context API</strong> and the <strong>useContext</strong> hook to allow prop values to be shared easily between components, without having to explicitly pass them as variables through every level. The steps are actually quite straightforward!</p>
          <ol>
            <li><p>Create a React Context in the highest level of the app that needs access to the values:</p>
              <div class="codecontainer">
                <code>
                  const myContext = React.createContext();
                </code>
              </div>
            </li>
            <li><p>The Context we created is an object that contains two values: { Provider, Consumer }.</p></li>
            <li><p>In the render section, enclose the app's children with myContext.Provider, and add a <strong>value</strong> attribute where we pass our state variables as an object:</p>
                <div class="codecontainer">
                  <pre>
export default function myApp() {
  const [count, setCount] = useState(1);
  const [greeting, setGreeting] = useState('Hai thar!');

  return (
    &lt;myContext.Provider value={{
      count,
      greeting,
      setCount,
      setGreeting
    }}&gt;
      &lt;div&gt;
        &lt;ChildComponent /&gt;
      &lt;/div&gt;
    &lt;/myContext.Provider&gt;
  );
}
                </pre>
              </div>
            </li>
            <li><p>To access the state in the myContext.Provider value from any child component that needs it, import React's useContext hook and pass the Context, myContext as a parameter.</p>
              <div class="codecontainer">
                <pre>
import React, { useContext } from 'react';

export default function ChildComponent() {
  const value = useContext(myContext);
  return (
    &lt;div&gt;The value of the greeting state variable: {value.greeting}&lt;/div&gt;
  );
}
              </pre>
              </div>      
            </li>
            <li><p>If we want to update state from the ChildComponent, the setGreeting and setCount methods are also available in the Context. Cool!</p>
              <div class="codecontainer">
                  <pre>
  import React, { useContext } from 'react';
  
  export default function ChildComponent() {
    const value = useContext(myContext);
    return (
      &lt;&gt;
        &lt;div&gt;The value of the greeting state variable: {value.greeting}&lt;/div&gt;
        &lt;label&gt;Update Greeting: &lt;/label&gt;
        &lt;input type="text" name="greeting" onChange={e =&gt; value.setGreeting(e.target.value)} value={greeting} /&gt;
      &lt;/&gt;
    );
  }
                </pre>
              </div>  
            </li>
          </ol>
          <p>Importantly, when the values provided by myContext.Provider change, the value will also be updated in all child components that use those values, triggering them to re-render, and the re-renders are <strong>recursive</strong>. That is, if a child component that uses useContext re-renders, all its children <strong>that use the useContext</strong> (but not the children that don't) will also re-render! Hence, the app could take a performance hit. To remedy this, we can use React memo or PureComponent on the children so they don't re-render if they do not need to.</p>
          <p>The React useContext hook also allows us to create multiple Contexts, and we can then nest child components in the ones they need access to.</p>
        </section>
        <section class="main-section" id="useReducer">
          <header>useReducer</header>
          <p>A reducer is a function that executes code to update global state values depending on an action that is sent (dispatched) to it as a parameter. The name "reducer" comes from the fact that the reducer function receives two values, an action and the current state object. It then "reduces" these two values into one that it returns as the new state. To help remember the concept of a reducer, think of the Array reduce method that accepts 1) an accumulator and 2) each item of the array, to reduce an array to a single value. This pattern is what Redux uses to provide access to state variables from React components. Ultimately, a reducer takes in an action and a previous state value, and returns a new state.</p>
          <p>There are several important rules for a reducer function to follow:</p>
          <ul>
            <li>The code inside the reducer function should never mutate its arguments, which are the current state and the dispatched action. To return a new state, a copy of the original should be made first.</li>
            <li>The reducer code should not be generating side effects, such as database or API calls. It should be a pure function.</li>
            <li>As well, any functions that the reducer calls within its code should always be pure functions themselves. That is, their output should only depend on their input. For example, Date.now() or Math.random() are <strong>not</strong> pure functions.</li>
          </ul>
          <p>(Copes, 2019)</p>
          <p>Using the <strong>useReducer</strong> hook, our React functional components can also dispatch actions to reducer functions that will run code and update a new copy of state based on the value of the action. An action is essentially just an object with a constant property, "type", that acts as the command sent to the reducer function optionally accompanied by an optional data payload. *By default react will pass the state to the dispatcher. but if you want to pass some data the you can add it in the object and pass that object to dispatch.</p>
          <p>For example, the below code demonstrates, again, a quintessential counter function. This time, however, it uses a reducer function to update the value of the count state depending on whether the user dispatches, by choosing a button to click, an "increment", "decrement", or "reset" action. Notice, as well, that the dispatch function expects its parameter to be an <strong>object</strong> type.</p>
          <div class="codecontainer">
            <pre>
import React, { useReducer } from 'react';

const INCREMENT = "increment";
const DECREMENT = "decrement";
const RESET = "reset";
const initialArg = 0;

const reducer = (state = initialArg, action) => {
  switch(action.type) {
    case INCREMENT:
      return state + 1;
    case DECREMENT:
      return state - 1;
    case RESET:
      return 0;
    default:
      &lt;!-- throw new Error(); --&gt;
      return state;
  }
}

export default function Counter() {

  const [count, dispatch] = useReducer(reducer, initialArg)

  return (
    &lt;&gt;
      &lt;div&gt;Counter: {count}&lt;/div&gt;
      &lt;button onClick={increment =&gt; dispatch({ type: INCREMENT })}&gt;INCREMENT&lt;/button&gt;
      &lt;button onClick={decrement =&gt; dispatch({ type: DECREMENT })}&gt;DECREMENT&lt;/button&gt;
      &lt;button onClick={reset =&gt; dispatch({ type: RESET })}&gt;RESET&lt;/button&gt;
      &lt;/&gt;
    );
}
          </pre>
        </div>
        <p>Sometimes, you will see a useReducer hook with three parameters instead of two. In addition to the reducer and the initialArg parameters is a third <strong>init function</strong>. 
        <div class="codecontainer">
          <code>
            const [state, dispatch] = useReducer(reducer, initialArg, init);
          </code>
        </div>
        <p>We can create an init function and pass it as a parameter to the useReducer hook in order to create the initial state <strong>lazily</strong>, meaning that we can now calculate the initial state outside the reducer or reset it because of a certain action. We don't need to compute the initial state, that is, until it is needed. Notice in the code below how the reducer calls the init function in response to the "reset" action, which is calculated at that time only.</p>
        <div class="codecontainer">
          <pre>
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({type: 'reset', payload: initialCount})}&gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

// Code sample from (Reactjs.org, n.d.)
          </pre>
        </div>
        <p>useReducer is much like useState, except that it has a reducer function as an intermediary for when we need to change the state (Ceddia, 2018). Thus, instead of setting state directly, we can execute the dispatch function with any action, and the reducer will execute code based on the action it receives. The reducer will ultimately update the state and return it, and the state change will therefore cause a re-render.</p>
        <p>The useReducer hook, then, is often used instead of useState to manage state that is more complex that primitive values, such as nested objects and arrays. It is more suited to code where the state depends on the previous state, since that is received by the reducer function.</p>
        <div class="codecontainer">
          <pre>
const [state, dispatch] = React.useReducer(
  fetchUsersReducer,
  {
    users: [
      { name: 'John', subscribred: false },
      { name: 'Jane', subscribred: true },
    ],
    loading: false,
    error: false,
  },
);
          </pre>
        </div>
        <p>The code above shows a state with a complicated shape. If any parameters depend on each other, also, the useReducer hook allows us to encapsulate everything nicely into the single reducer function.</p>
        <p>Finally, since a reducer is a pure function that always returns the same output for the same input parameters with zero side effects, it is suited for testing, since it does not depend on React (Spukas, 2019).</p>

      <!-- USE EXAMPLE FROM youtube tutorial (Dave Ceddia) -->    
      
        </section>
        <section class="main-section" id="useCallback">
          <header>useCallback</header>
          <p>When you have a child component that needs to re-render often, all its functions will reinstantiate as well, even those that handle a different state variable than the one that changed. Although this might not be a big deal in a smaller component, it can cause a performance hit in a more complex component that has multiple state values. If one state value is changed, it should only cause functions that access it to reinstantiate, and leave functions that do not alone, yet this is not the case. In the example code below, updating the value of the "count1" state will cause a re-render that recreates <strong>all</strong> functions in the component, including <strong>both</strong> functions that don't even concern count1. The incrementCount2 and decrementCount2 functions are for count2 only, but are recreated anyway when count1 is updated.</p>
          <div class="codecontainer">
            <pre>
import React, { useState } from "react";

const Counter = () =&gt; {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);

  // count1 functions. When count1 is updated, the component
  // re-renders and has to recreate all the functions, even the two
  // that do not even use count1.
  const incrementCount1 = () => {
    setCount1(count1 + 1);
  };
  const decrementCount1 = () => {
    setCount1(count1 - 1);
  };

  // count2 functions. When count2 is updated, the component
  // re-renders and has to recreate all the functions, even the two
  // that do not even use count2.
  const incrementCount2 = () => {
    setCount2(count2 + 1);
  };
  const decrementCount2 = () => {
    setCount2(count2 - 1);
  };

  return (
    &lt;&gt;
      Count1: {count1} &lt;br /&gt;
      Count2: {count2} &lt;br /&gt;
      &lt;button onClick={incrementCount1}&gt;Increment count1&lt;/button&gt;
      &lt;button onClick={decrementCount1}&gt;Decrement count1&lt;/button&gt;
      &lt;button onClick={incrementCount2}&gt;Increment count2&lt;/button&gt;
      &lt;button onClick={decrementCount2}&gt;Decrement count2&lt;/button&gt;
    &lt;/&gt;
  );
};

export default Counter;                
            </pre>
          </div>
          <p>To solve the problem, and make it so that we don't recreate functions in a re-render that do not concern the state value that was updated, we can use the useCallback hook to <strong>memoize</strong> a function's callback so it only changes if one of its inputs changes (Noring, n.d.).</p>
          <p>All we need to do is wrap each of the functions with a useCallback that has an array for its second parameter that includes any state values that should cause the function to be recreated when the component re-renders.</p>
          <div class="codecontainer">
              <pre>
import React, { useState } from "react";

const Counter = () =&gt; {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);

  // count1 functions. When count1 is updated, the component
  // re-renders and has to recreate all the functions, even the two
  // that do not even use count1.
  const incrementCount1 = useCallback(() => {
    setCount1(count1 + 1);
  }, [count1]);

  const decrementCount1 = useCallback(() => {
    setCount1(count1 - 1);
  }, [count1]);

  // count2 functions. When count2 is updated, the component
  // re-renders and has to recreate all the functions, even the two
  // that do not even use count2.
  const incrementCount2 = useCallback(() => {
    setCount2(count2 + 1);
  }, [count2]);

  const decrementCount2 = useCallback(() => {
    setCount2(count2 - 1);
  }, [count2]);

  return (
    &lt;&gt;
      Count1: {count1} &lt;br /&gt;
      Count2: {count2} &lt;br /&gt;
      &lt;button onClick={incrementCount1}&gt;Increment count1&lt;/button&gt;
      &lt;button onClick={decrementCount1}&gt;Decrement count1&lt;/button&gt;
      &lt;button onClick={incrementCount2}&gt;Increment count2&lt;/button&gt;
      &lt;button onClick={decrementCount2}&gt;Decrement count2&lt;/button&gt;
    &lt;/&gt;
  );
};

export default Counter;
              </pre>
            </div>
            <p>Now, with each call wrapped in useCallback, the functions will only be reinstantiated when the state values specified in the second parameter array are changed, thus optimizing performance.</p>
        </section>
        <section class="main-section" id="useMemo">
          <header>useMemo</header>
          <p>Although the useCallback and useMemo React hooks seem similar, while useCallback is used to create a memoized <strong>callback function</strong> to child components, the purpose of useMemo, in contrast, is to create a memoized <strong>value</strong>.</p>
          <p>When an operation is computationally expensive or slow, a memoized value means that after it is calculated once, the value is cached so that next time we need it, we don't need to perform the expensive calculation again, and can instead used the cached version. In other words, if the inputs have not changed, neither should the output, therefore it does not need to be re-calculated using an expensive function.</p>
          <p>To use the useMemo hook, we need to pass it two parameters, a function (the slow, costly one) that creates the value we want to be memoized, and an array of parameters that if they change, trigger the function to run again to re-calculate the memoized value. If none of the parameters in the array change, the function does not need to run since the value should not be changed, which optimizes our code. Every parameter for the callback function that calculates the memoized value should be included in the array, since that is what the array items represent (ReactJS.org, n.d.).</p>
          <div class="codecontainer">
            <code>
                const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
            </code>
          </div>
          <p>Above, if either dependency, a or b, changes, we have to re-calculate the value of "memoizedValue" with the computeExpensiveValue function. Otherwise, if neither a nor b changes, we can use "memoizedValue" without computing it. The first time it is computed is when a component is first mounted, and it should not include side effects, since those should be in the useEffect hook instead. The useMemo and useEFfect hooks have similar code with an array as the second parameter, but useEffect is for side effects, whereas useMemo is for memoized values.</p>
          <p>*Importantly, if the array is left out like the below code, the value will never be memoized, because there are no dependencies saying that it shouldn't be recalculated. That is, the value would be recalculated every time the component re-renders if there are no parameters in the array.</p>
          <div class="codecontainer">
              <code>
                  const memoizedValue = useMemo(() => computeExpensiveValue(a, b));
              </code>
          </div>
          <p>On the other hand, if the array is included, but empty, it is like saying that the function should only be run once, when the component renders for the first time.</p>
          <div class="codecontainer">
              <code>
                  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), []);
              </code>
          </div>        
          <p>In addition, code should work regardless of whether useMemo works or not, as the React documentation advises (ReactJS.org, n.d.). Thus, we can first write our code <strong>without</strong> using useMemo, then add it in afterwards.</p>
          <p>The useCallback and useMemo hooks replace the shouldComponentUpdate lifecycle method or PureComponent that React classes use, and allows memoization to be used with React functional components.</p>
        </section>
        <section class="main-section" id="useImperativeHandle">
          <header>useImperativeHandle</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useLayoutEffect">
          <header>useLayoutEffect</header>
          <p>In class-based React apps, we used lifecycle methods instead of hooks. For example, we could control the program using componentDidMount or componentDidUpdate. People familiar with coding classes tend to look for hooks that can substitute for lifecycle methods, and for componentDidMount and componentDidUpdate, hope that the useEffect hook will realize this goal. The useEffect hook, however, works differently in an important way.</p>
          <p>Although useEffect, like componentDidMount or componentDidUpdate, also runs after a state change, its code is <strong>non-blocking</strong>, so other code coming after it will continue to run rather than wait for the useEffect code to complete. When someone is accustomed to lifecycle methods like componentDidMount that <strong>block</strong>, they might be surprised by useEffect's asynchronous behavior and when state values are updated. React hooks make the developer think about their code asyncronously, which results in better, more efficient code.</p>
          <p>Although most effects can run asynchronously, there are some cases that synchronous code might be needed, such as for measuring layout, scroll position, or element styles. In cases like these where we need the effect to update the DOM before it is painted, we have the useLayoutEffect React hook to use in place of useEffect. This behaves more like componentDidMount or componentDidUpdate.</p>
          <p> The useLayoutEffect hook runs <strong>after</strong> the DOM is updated with any new mutations, but <strong>before</strong> the browser has repainted them, so the user sees the latest view. In contrast, since the useEffect hook is asynchronous, the browser may have already been repainted before the effect code has completed, and the user will likely see a view that is one state behind.</p>
          <p>The API for useLayoutEffect is <strong>the same</strong> as useEffect, but useLayoutEffect runs synchronously, preventing other code from running until the effects have finished executing.</p>
          <div class="codecontainer">
              <pre>
              
              </pre>
            </div>
            <p>Importantly, 99% of the time we should be able to use the useEffect hook, rather than blocking the code with useLayoutEffect.</p>
        </section>
        <section class="main-section" id="useDebugValue">
          <header>useDebugValue</header>
          <p>The useDebugValue is a hook that is simply meant to make debugging custom hooks easier by giving them custom names that show in the React DevTools browser extension. 
            That way, when an error occurs we can see the custom name in the DevTools stack trace, which makes it far easier to find the problem in our code.</p>
          <p>The useDebugValue hook is <strong>only</strong> executed when both the React DevTools extension is open in the browser, and the custom hook related to the useDebugValue 
            is being inspected by the developer. Because the function passed to useDebugValue does not run except under these circumstances, the function has no performance impact when
            the application is running normally. Nevertheless, the React documentation advises to use the useDebugValue hook sparingly, rather than for every custom hook. It is best used 
            when custom hooks are part of a shared library.</p>
          <p>The below code is a React custom hook called useLoginStatus. The function computed in the useDebugValue hook will reveal during debugging whether or not the state of 
            the user was online when the error happened.</p>
          <div class="codecontainer">
            <pre>
import React, { useState, useDebugValue } from 'react';

export default function useLoginStatus(user) {
  const [loggedIn, setLoggedIn] = useState(null);

  // Other code.

  useDebugValue(loggedIn ? 'Logged In' : 'Logged Out');

  return loggedIn;
}
            </pre>
          </div>
          <p>In the debug tools area of React DevTools, we would see something like the below:</p>
          <div class="codecontainer">
              <pre>
hooks
>Dispatch:
>History:
>LoginStatus: "Logged In"
    State: true
              </pre>
            </div>
        </section>
      </main>
    </div>
    <footer>
      <header>References:</header>
      <p class="reference">Bishard, E. (n.d.). The Guide to Learning React Hooks. Retrieved from
        <a href="https://www.telerik.com/kendo-react-ui/react-hooks-guide" target="_blank">
          https://www.telerik.com/kendo-react-ui/react-hooks-guide</a>
      </p>
      <p class="reference">Ceddia, D. (2018, October 30). How to Use the useReducer Hook. Retrieved from
        <a href="https://daveceddia.com/usereducer-hook-examples" target="_blank">
          https://daveceddia.com/usereducer-hook-examples</a>
      </p>
      <p class="reference">Ceddia, D. (2019, January 30). The useReducer Hook. Retrieved from
        <a href="https://www.youtube.com/watch?time_continue=1&v=sYDFCuZHrqw&feature=emb_logo" target="_blank">
          https://www.youtube.com/watch?time_continue=1&v=sYDFCuZHrqw&feature=emb_logo</a>
      </p>
      <p class="reference">Copes, F. (2019, July 20). How to use the useMemo React hook. Retrieved from
        <a href="https://flaviocopes.com/react-hook-usememo" target="_blank">
          https://flaviocopes.com/react-hook-usememo</a>
      </p>
      <p class="reference">Copes, F. (2019, July 23). How to use the useReducer React hook. Retrieved from
        <a href="https://flaviocopes.com/react-hook-usereducer" target="_blank">
          https://flaviocopes.com/react-hook-usereducer</a>
      </p>
      <p class="reference">Dodds, K. (2018, November 26). useEffect vs. useLayoutEffect. Retrieved from
        <a href="https://kentcdodds.com/blog/useeffect-vs-uselayouteffect" target="_blank">
          https://kentcdodds.com/blog/useeffect-vs-uselayouteffect</a>
      </p>
      <p class="reference">ReactJS.org (n.d.). Hooks API Reference. Retrieved from
        <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank">
          https://reactjs.org/docs/hooks-reference.html</a>
      </p>
      <p class="reference">Noring, C. (n.d.). React Book. Retrieved from
        <a href="https://softchris.github.io/books/react" target="_blank">
          https://softchris.github.io/books/react</a>
      </p>
      <p class="reference">Spukas, L. (2019, August 18). 3 Reasons to useReducer() over useState(). Retrieved from
        <a href="https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad" target="_blank">
          https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad</a>
      </p>
      <p class="reference">"techsith" (YouTube.com), L. (2019, July 15). React Hook useRef and forwarding refs with
        forwardRef. Retrieved from
        <a href="https://www.youtube.com/watch?v=ScT4ElKd6eo" target="_blank">
          https://www.youtube.com/watch?v=ScT4ElKd6eo</a>
      </p>
      <p class="reference">Wieruch, R. (2020, April 25). How to use React Ref. Retrieved from
        <a href="https://www.robinwieruch.de/react-ref" target="_blank">
          https://www.robinwieruch.de/react-ref</a>
      </p>
    </footer>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>

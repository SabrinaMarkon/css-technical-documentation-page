<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="./styles.css" />
    <title>React Hooks Tutorial</title>
  </head>
  <body>
    <div id="content">
      <nav id="navbar">
        <header>React Hooks Tutorial</header>
        <ul>
          <li><a href="#Important_Rules" class="nav-link" rel="internal">Important Rules</a></li>
          <li><a href="#useState" class="nav-link" rel="internal">useState</a></li>
          <li><a href="#useRef" class="nav-link" rel="internal">useRef</a></li>
          <li><a href="#useEffect" class="nav-link" rel="internal">useEffect</a></li>
          <li><a href="#useContext" class="nav-link" rel="internal">useContext</a></li>
          <li><a href="#useReducer" class="nav-link" rel="internal">useReducer</a></li>
          <li><a href="#useCallback" class="nav-link" rel="internal">useCallback</a></li>
          <li><a href="#useMemo" class="nav-link" rel="internal">useMemo</a></li>
          <li><a href="#useImperativeHandle" class="nav-link" rel="internal">useImperativeHandle</a></li>
          <li><a href="#useLayoutEffect" class="nav-link" rel="internal">useLayoutEffect</a></li>
          <li><a href="#useDebugValue" class="nav-link" rel="internal">useDebugValue</a></li>
        </ul>
      </nav>
      <main id="main-doc">
          <section class="main-section" id="Important_Rules">
            <header>Important Rules</header>
            <ul>
              <li>Hooks should never be called from loops, conditionals, or nested functions.</li>
              <li>Hooks should only be at the top level of your component.</li>
              <li>Hooks can only be called in React functional components (not classes).</li>
              <li>Hooks should never be called in regular functions (as opposed to React functional components).</li>
              <li>Hooks can be called from other hooks.</li>
              <li>You can enforce these rules with <a href="https://reactjs.org/docs/hooks-rules.html#eslint-plugin" target="_blank">
                ES Lint</a>.</li>
            </ul>
          </section>
        <section class="main-section" id="useState">
          <header>useState</header>
          <p>React functional components use the <strong>useState</strong> React hook to keep track of "stateful" values, or 
          variable value changes that we need to keep track of in our application.</p>
          <p>In the code below, you can see a typical example of a useState hook.</p>
          <div class="codecontainer">
            <code>
              let initialState = 0;<br />
              const [count, setCount] = useState(initialState);
            </code>
          </div>
          <p>The useState hook is passed an optional initialState parameter, and is assigned to a destructured array that
          tells us the stateful variable's name our program can use, along with a "set" function that our program can use to
          update that variable's value.</p>
          <ul>
            <li><strong>let initialState = 0</strong> is the optional starting value of the count variable.</li>
            <li><strong>count</strong> is the name of the stateful value our program needs to read and update.</li>
            <li><strong>setCount</strong> is the name of the declarative function we will call that will automatically
               update the value of count for us to whatever we tell it to.</li>
          </ul>
          <p>So, in our program, if want to increment count whenever we click a button, the onClick function would
            call <strong>setCount(newCount)</strong> where newCount = ++count;</p>
          </p>
          <p>Example of a functional component using useState to keep track of a counter:</p>
          <div class="codecontainer">
            <xmp>
/* When the "Click Me" button is clicked, the onClick event fires
 * and the incrementCount function is called that uses setCount to 
 * increment the count variable. */

import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);
  const incrementCount = () => setCount(count + 1);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={incrementCount}>Click Me</button>
    </div>
  )
}

export default Counter;
          </xmp>
        </div>
        </p>So for each stateful variable your program needs, the <strong>generalized</strong> 
        format to set up the useState hook is:</p>
        <div class="codecontainer">
            <code>
              const [state, setState] = useState(initialState);
            </code>
         </div>
        </section>
        <section class="main-section" id="useRef">
          <header>useRef</header>
          <p>useRef is a hook that mutates the current value of a variable that we initialize with an initial value.
          Its major difference to the useState hook is that it only updates the value of the variable, but does <strong>not</strong>
          update state. Consequently, useRef does <strong>not</strong> cause a re-render like useState does.</p>
          <p>We create a <strong>ref</strong> for a React functional component like this:</p>
          <div class="codecontainer">
            <code>
              const wasClicked = useRef(false);
            </code>
          </div>
          <p>And we mutate its value using its <strong>current</strong> property:</p>
          <div class="codecontainer">
            <code>
              wasClicked.current = true;
            </code>
          </div>
          <p>If you noticed that wasClicked is a constant, yet we are mutating a value, it is because
          we are updating the property called "current", not mutating the wasClicked object reference itself.</p>
          <p>The functional component below uses a useRef hook. What will be logged to the console? What will appear in the webpage itself (DOM)?</p>
          <div class="codecontainer">
            <xmp>
  import React, { useRef } from "react";

  const clickButton = () => {
    const wasClicked = useRef("Not Clicked Yet");
    const onClick = () => {
      wasClicked.current = "Clicked";
      console.log("Has clicked button? " + wasClicked.current);
    };
  
    return (
      <div>
        <p>The value of wasClicked is: {wasClicked.current}</p>
        <button onClick={onClick}>Click Me</button>
      </div>
    );
  };
  
  export default clickButton;
            </xmp>
          </div>
          <p>The code above will update the value of wasClicked and log it to the console, 
            however it will not cause the page to re-render, so the text in the DOM stays the <strong>same</strong>.</p>
          <ul>
            <li>Console when the component mounts for the first time: nothing in the console</li>
            <li>DOM when the component mounts for the first time: "The value of wasClicked is: Not Clicked Yet"</li>
            <li>Console when the button is clicked: "Has clicked button? Clicked"</li>
            <li>DOM when the button is clicked: "The value of wasClicked is: <strong>Not Clicked Yet</strong>".</li>
          </ul>
          <p>The ref is mutated when the button is clicked, but it does not trigger the DOM to be re-rendered, unlike when we use useState.</p>
          <p>So what would useRef be good for?</p>
          <p>Well, if we wanted to track a state value that changes but shouldn't cause a re-render, we can create a useRef hook to use it as an <strong>instance variable</strong>.</p>
          </p>A good use of this, for example, would be a situation where we want to run certain code whenever a component updates, but <strong>not</strong> when the component is first rendered.</p>
          <p>For most situations, we would use the <a href="#useEffect">useEffect</a> hook to automatically execute the code when the component updates.</p>
          <p>On the other hand, however, the <a href="#useEffect">useEffect</a> hook is also triggered when a component is <strong>first mounted</strong>, which therefore doesn't meet our requirement above.</p>
          <p>In the below code, you can see how we create a variable, using the useRef hook, called firstRender, whose value defaults to true, but is changed to false when the component re-renders. The useEffect hook runs every time a component is rendered or re-rendered, so if we don't want it to run that first time when the component is rendered for the first time, we can check the ref variable firstRender to make sure its value is false before running the code.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useRef, useEffect } from 'react';
export default function ComponentWithRefInstanceVariable() {
  const [count, setCount] = useState(0);
 
  function onClick() {
    setCount(count + 1);
  }
 
  const isFirstRender = .useRef(true);
 
  useEffect(() => {
    if (isFirstRender.current) {

      /* 
      * This is the first time the component is mounted, so DO NOT run the
      * code (in the else statement). Set isFirstRender to false though
      * for when the component loads again.
      */

      isFirstRender.current = false;

    } else {
      // this won't run if isFirstRender.current = true, which is only
      // when the component is FIRST rendered. 
      console.log(
        `
          I am a useEffect hook's logic
          which runs for a component's
          re-render.
        `
      );
    }
  });
 
  return (
    <div>
      <p>{count}</p>
 
      <button type="button" onClick={onClick}>
        Increase
      </button>
    </div>
  );
}
// Code example (Wieruch, 2020). 
            </xmp>
          </div>
        </section>
        <section class="main-section" id="useEffect">
          <header>useEffect</header>
          <p>When we update state, many apps also need to execute side-effects, such as making API calls, communicating with a database, or updating local storage. Since state causes re-renders, we can use the useEffect hook to run our side-effect every time I render or re-render occurs, or just when a certain state value is updated.</p>
          <p>useEffect has a second argument, which when left out, defaults to mean that the side-effect code should execute every time any state value is changed. When this parameter is provided to useEffect, though, we can change when it runs.</p>
          <ol>
            <li>
              <p>Leave out the second argument so code in useEffect runs on mount and re-render of the component:</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  });
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an empty array, which means the useEffect code runs <strong>only</strong> when the component is first mounted, but not when state is updated.</p>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, []);
                </code>
              </div>
            </li>
            <li>
              <p>Set the second parameter as an array containing a list of one or more state variables. When any of these is mutated, execute the useEffect code. Other state variables do not cause the useEffect code to be invoked.</p>
            </li>
              <div class="codecontainer">
                <code>
                  useEffect(() => {
                    /* side-effect code. */
                  }, [count, color, loggedIn]);
                </code>
              </div>
          </ol>
          <p>In a component, we can use useEffect as many times as we need! Our code ends up clean and readable, replacing the two lifecycle methods that are required by class components to accomplish the same things (componentDidMount and componentDidUpdate).</p>
          <p>Below, the code contained within the useEffect block executes every time the component is rendered. That is, when it first mounts along with every state update that causes a re-render.</p>
          <div class="codecontainer">
            <xmp>
import { useState, useEffect } from 'react';
export default function useEffectExample() {
  const [count, setCount] = useState(0);
  const [color, setColor] = useState('pink');
 
  function onCountClick() {
    setCount(count + 1);
  }

  function onColorClick() {
    setColor('blue');
  }
 
  useEffect(() => {
    // Executes every time state is changed. 
    // Any state value.
    // i.e. a fetch or axios request.
  });
 
   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the color state changes.
    // i.e. some other side-effect.
  }, [color]);

   useEffect(() => {
    // Executes <strong>only</strong> 
    // when the component mounts for the first time.
    // i.e. some other side-effect.
  }, []);

  return (
    <div>
      <p>{count}</p>
      <button type="button" onClick={onCountClick}>
        Increment Counter
      </button>
      <p>{color}</p>
      <button type="button" onClick={onColorClick}>
        Change Color
      </button>
    </div>
  );
}
            </xmp>
          </div>
          <p>Before another effect runs after a re-render, React will clean up the previous render's effects. Some subscriptions, however, may need useEffect to return a cleanup function (anonymous or named is fine) that automatically executes and unsubscribes.</p>
          <p>The useEffect hook is also wonderful because it does not block the browser when its side-effects are being run, which makes the app feel fast and responsive!</p>
        </section>
        <section class="main-section" id="useContext">
          <header>useContext</header>
          <p>The React useContext hook is used in combination with the React Context API.</p>
          <p>Without using Context in React, props that need to be shared between components are passed as attributes from parent to child to child's child, etc. In addition, functions that mutate the same values are also passed to child components by the parent as attributes that the child component can use to pass mutated props back to the parent.</p>
          <p>As you might guess, if the React tree has many levels of parent and child components, this process could become more error prone and unwieldy. It can be hard to keep track of which props are available to a given component, for instance, and code repetition, such as of attributes and functions that pass to the next parent up the tree, makes code less readable. Moreover, some of the components in the process might not even need access to the prop but have to handle it anyway.</p>
          <p>So, instead of "prop drilling" through multiple levels in a React component tree, we can use the <strong>Context API</strong> and the <strong>useContext</strong> hook to allow prop values to be shared easily between components, without having to explicitly pass them as variables through every level. The steps are actually quite straightforward!</p>
          <ol>
            <li>Create a React Context in the highest level of the app that needs access to the values:
              <div class="codecontainer">
                <code>
                  const myContext = React.createContext();
                </code>
              </div>
            </li>
            <li>The Context we created is an object that contains two values: { Provider, Consumer }.</li>
            <li>In the render section, enclose the app's children with myContext.Provider, and the attributes we want child components to have access to:
                <div class="codecontainer">
                  <xmp>
function myApp() {
  return (
    <myContext.Provider value1={'Hello'} value2={'World'}>
      <div>
        <ChildComponent />
      </div>
    </myContext.Provider>
  );
}
                </xmp>
              </div>
            </li>
            <li>To access the values, value1 and value2, from any of myApp's child components, import React's useContext hook and pass the Context, myContext as a parameter.
              <div class="codecontainer">
                <xmp>
import React, { useContext } from 'react';

function ChildComponent() {
  const value1 = useContext(myContext);
  const value2 = useContext(myContext);
  return <div>value1 and value2 say: {value1} {value2}!</div>;
}
              </xmp>
              </div>      
            </li>
          </ol>
        </section>
        <section class="main-section" id="useReducer">
          <header>useReducer</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useCallback">
          <header>useCallback</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useMemo">
          <header>useMemo</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useImperativeHandle">
          <header>useImperativeHandle</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useLayoutEffect">
          <header>useLayoutEffect</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
        <section class="main-section" id="useDebugValue">
          <header>useDebugValue</header>
          <p></p>
          <p></p>
          <code></code>
          <ul>
            <li></li>
            <li></li>
            <li></li>
          </ul>
        </section>
      </main>
    </div>
    <footer>
        <header>References:</header>
        <p class="reference">Bishard, E. (n.d.). The Guide to Learning React Hooks. Retrieved from 
          <a href="https://www.telerik.com/kendo-react-ui/react-hooks-guide" target="_blank">
            https://www.telerik.com/kendo-react-ui/react-hooks-guide</a>
        </p>
        <p class="reference">ReactJS.org (n.d.). Hooks API Reference. Retrieved from
          <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank">
            https://reactjs.org/docs/hooks-reference.html</a>
        </p>
        <p class="reference">Wieruch, R. (2020, April 25). How to use React Ref. Retrieved from
          <a href="https://www.robinwieruch.de/react-ref" target="_blank">
            https://www.robinwieruch.de/react-ref</a>
        </p> 
    </footer>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>
